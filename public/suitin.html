<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Emisor de Audio</title>
  <script src="https://cdn.socket.io/4.0.1/socket.io.min.js"></script>
</head>
<body>
  <h1>Emisor de Audio - Usuario</h1>
  <button onclick="startTransmission()">Iniciar Transmisión</button>

  <script>
    let localStream;
    let socket;
    let peerConnection;

    const userId = location.pathname.split('/').pop().split('.').shift();
    const audioBitrate = 48000; // 16 etc kbps
    const audioSampleRate = 44100; // kHz
    const audioChannels = 2; // Estéreo

    async function startTransmission() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ 
          


          audio: {
            mandatory: {
                'OfferToReceiveAudio': true,
                'OfferToReceiveVideo': false,
                bitrate: audioBitrate,
                sampleRate: audioSampleRate,
                channelCount: audioChannels,
                //'codec': 'aac' // Especificar AAC como codec obligatorio

		            autoGainControl: false,
                echoCancellation: false,
                noiseSuppression: false,
                googAutoGainControl: false
            },

          },
          video: false 
        });
        console.log("Micrófono capturado");

        socket = io("https://radioenlace.onrender.com");

        socket.on('connect', () => {
          console.log("Conectado al servidor Socket.IO con ID:", socket.id);
          createAndSendOffer();
        });

        socket.on('signal', async (data) => {
          if (data.type === 'answer' && data.id === userId) {
            await peerConnection.setRemoteDescription(data.answer);
            console.log("Respuesta establecida");
          } else if (data.type === 'candidate' && data.id === userId) {
            await peerConnection.addIceCandidate(data.candidate);
            console.log("Candidato ICE añadido:", data.candidate);
          }
        });

        // Al recibir la señal de reconexión, envía una nueva oferta
        socket.on('reconnect', () => {
          console.log("Reconexión solicitada, enviando nueva oferta...");
          createAndSendOffer();
        });

        socket.on('disconnect', () => {
          console.log("Desconectado del servidor Socket.IO");
        });

      } catch (error) {
        console.error("Error al capturar el micrófono o configurar WebRTC:", error);
      }
    }

    async function createAndSendOffer() {
      peerConnection = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });

      localStream.getTracks().forEach(track => {
        if (track.kind === 'audio') {
          const sender = peerConnection.addTrack(track, localStream);
          console.log('Frecuencia de muestreo del audio:', track.getSettings().sampleRate);

          // Configurar parámetros de codificación de audio (Codecs Opus)
          const parameters = sender.getParameters();
          if (!parameters.encodings) {
            parameters.encodings = [{}];
          }
          parameters.encodings[0].maxBitrate = audioBitrate;
          parameters.encodings[0].codecPayloadType = 111;
          parameters.encodings[0].sampleRate = 16000;

          sender.setParameters(parameters); 
          console.log('Parámetros de codificación:', parameters); 
      console.log('maxBitrate:', parameters.encodings[0].maxBitrate);
      console.log('codecPayloadType:', parameters.encodings[0].codecPayloadType);
      console.log('codecPayloadType:', parameters.encodings[0].sampleRate);
        }
      });




      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit('signal', {
            type: 'candidate',
            id: userId,
            candidate: event.candidate
          });
        }
      };

      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      socket.emit('signal', {
        type: 'offer',
        id: userId,
        offer: offer
      });
    }
  </script>
</body>
</html>